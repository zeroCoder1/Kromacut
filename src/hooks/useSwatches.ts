import { useEffect, useRef, useState } from 'react';
import { rgbToHsl } from '../lib/color';

// Manages swatch computation with cancellation & immediate override
export interface SwatchEntry {
    hex: string;
    a: number;
    count: number;
    isTransparent?: boolean;
}
export function useSwatches(imageSrc: string | null) {
    const [swatches, setSwatches] = useState<SwatchEntry[]>([]);
    const [loading, setLoading] = useState(false);
    const [imageDimensions, setImageDimensions] = useState<{ width: number; height: number } | null>(null);
    const runRef = useRef(0);
    const SWATCH_CAP = 2 ** 14; // matches previous constant

    const invalidate = () => {
        runRef.current++;
        setLoading(false);
    };

    const immediateOverride = (colors: SwatchEntry[]) => {
        runRef.current++; // cancel any inflight computation
        setSwatches(colors);
        setLoading(false);
    };

    useEffect(() => {
        let cancelled = false;
        const compute = async () => {
            if (!imageSrc) {
                runRef.current++;
                setSwatches([]);
                setImageDimensions(null);
                setLoading(false);
                return;
            }
            const runId = ++runRef.current;
            setSwatches([]);
            setLoading(true);
            try {
                const img = await new Promise<HTMLImageElement>((resolve, reject) => {
                    const i = new Image();
                    i.onload = () => resolve(i);
                    i.onerror = () => reject(new Error('image load failed'));
                    i.src = imageSrc;
                });
                if (runId !== runRef.current || cancelled) return;
                const w = img.naturalWidth;
                const h = img.naturalHeight;
                setImageDimensions({ width: w, height: h });
                const TILE = 1024;
                const map = new Map<number, number>();
                const tile = document.createElement('canvas');
                const tctx = tile.getContext('2d', {
                    willReadFrequently: true,
                });
                if (!tctx) {
                    setLoading(false);
                    return;
                }
                let transparentCount = 0;
                for (let y = 0; y < h; y += TILE) {
                    for (let x = 0; x < w; x += TILE) {
                        const sw = Math.min(TILE, w - x);
                        const sh = Math.min(TILE, h - y);
                        tile.width = sw;
                        tile.height = sh;
                        tctx.clearRect(0, 0, sw, sh);
                        tctx.drawImage(img, x, y, sw, sh, 0, 0, sw, sh);
                        const data = tctx.getImageData(0, 0, sw, sh).data;
                        for (let i = 0; i < data.length; i += 4) {
                            const a = data[i + 3];
                            if (a === 0) {
                                // accumulate fully transparent pixels into a single bucket
                                transparentCount++;
                                continue;
                            }
                            // include alpha in the key so semi-transparent colors are preserved
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const key = ((r << 24) | (g << 16) | (b << 8) | a) >>> 0;
                            map.set(key, (map.get(key) || 0) + 1);
                        }
                    }
                    await new Promise((r) => setTimeout(r, 0));
                    if (runId !== runRef.current || cancelled) return;
                }
                const top = Array.from(map.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, Math.min(map.size, SWATCH_CAP))
                    .map((entry) => {
                        const key = entry[0];
                        // decode unsigned 32-bit key with alpha in the low byte
                        const r = (key >>> 24) & 0xff;
                        const g = (key >>> 16) & 0xff;
                        const b = (key >>> 8) & 0xff;
                        const a = key & 0xff;
                        const hex =
                            '#' + [r, g, b].map((v) => v.toString(16).padStart(2, '0')).join('');
                        return {
                            hex,
                            a,
                            hsl: rgbToHsl(r, g, b),
                            freq: entry[1],
                        };
                    });
                top.sort((a, b) => {
                    if (a.hsl.h !== b.hsl.h) return a.hsl.h - b.hsl.h;
                    if (a.hsl.s !== b.hsl.s) return b.hsl.s - a.hsl.s;
                    return b.hsl.l - a.hsl.l;
                });
                // Present colors from darkest to lightest (reverse the previous ordering)
                top.reverse();
                if (runId === runRef.current && !cancelled) {
                    const result = top.map((t) => ({
                        hex: t.hex,
                        a: typeof t.a === 'number' ? t.a : 255,
                        count: t.freq,
                        isTransparent: typeof t.a === 'number' ? t.a === 0 : false,
                    }));
                    if (transparentCount > 0) {
                        // preserve the single fully-transparent bucket
                        result.push({
                            hex: '#000000',
                            a: 0,
                            count: transparentCount,
                            isTransparent: true,
                        });
                    }
                    setSwatches(result);
                    setLoading(false);
                }
            } catch (err) {
                if (runId === runRef.current && !cancelled) {
                    console.warn('swatches: compute failed', err);
                    setSwatches([]);
                    setLoading(false);
                }
            }
        };
        compute();
        return () => {
            cancelled = true;
        };
    }, [imageSrc, SWATCH_CAP]);

    return {
        swatches,
        swatchesLoading: loading,
        imageDimensions,
        invalidate,
        immediateOverride,
    };
}
